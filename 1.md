# Отложенное и немедленное выполнение в LINQ

### **Отложенное выполнение**
Напишем простой код

```C#
1. int[] nums = new int[] { 1, 4, 3, 2 };
2. var newIntMass = nums.OrderBy(x => x); //Сортировка
3. nums[1] = 0; 
4. foreach (int x in newIntMass)
5. {
6.    Console.Write(x+",");
7. }
  
```
<br>

Программа выведет 0,1,2,3 <br> 
&nbsp;&nbsp;&nbsp; Возможно ожидался другой результат. Если читать код построчно то можно предположить, что во 2 строке 
в _newIntMass_ будет _1, 0, 3, 4_. На самом деле ничего не произойдёт.
Дело в том, что OrderBy это отложенный запрос. Он не сработает пока не потребуется реализованное значение (статичный результат). Переменная _newIntMass_ просто сохраняет сведения, о том что делать, когда запрос нужно будет выполнить.
<br>&nbsp;&nbsp;&nbsp; Сортировка произошла на 4 строке, когда уже _nums_ выглядел так _{1,0,3,2}_. Такие _Linq_ методы вызываются, когда пройдет итерация или перебор.





<br><br>&nbsp;&nbsp;&nbsp; Рассмотрим другой пример
```C#
1. int[] nums = new int[] { 1, 4, 3, 2 };
2. var newIntMass = nums.Where(x => x>2).ToList();
3. nums[1] = 10;
4. foreach (int num in newIntMass)
5. {
6.     Console.Write(num+" ");//4 3
7. }
```
<img src="images\questionMark.jpg" alt="Вопрос" width="75" height="75"><br>
&nbsp;&nbsp;&nbsp; **Почему здесь 3 строка не повлияла на результат?**<br>
 Во 2 строке метод ToList() итерировал вычисления после WHERE(),тем самым зафиксировал результат.<br>
 ToList(), Sum() это методы немедленного выполнения<br><br>
<img src="images\attention.jpg" alt="Внимание" width="75" height="50"><br>
&nbsp;&nbsp;&nbsp; **Запомни**<br>
 &nbsp;&nbsp;&nbsp; Если метод выдает одно значение, а не (IEnumerable<T> или IQueryable<T>) или происходит преобразование последовательности в другой тип, то это метод немедленного выполнения<br>
Остальные за некоторыми исключениями методы отложенного выполнения<br><br>


&nbsp;&nbsp;&nbsp;**Так в чем же преимущества отложенного запроса?**<br>
**Почему не сделать все методы немедленного выполнения?**<br> 
 &nbsp;&nbsp;&nbsp; Рассмотрим  код
 ```C#
1. int[] nums = new int[] { 1, 4, 3, 2 };
2. var newIntMass = nums.Where(x => x>2);
3. int num1 = newIntMass.Sum();//7
4. nums[1] = 10; 
5. int num2=newIntMass.Sum();//13
6. Console.Write(num1+" "+num2 )// 7 13;
 ```   
&nbsp;&nbsp;&nbsp; В этом блоке кода мы хотим получить сумму чисел в массиве дважды. Один раз после создания, другой раз после изменения.<br>
Если бы метод Where() был немедленного выполнения, то пришлось вызывать его дважды. А если бы требовалось миллион итераций. С помощью этого кода можно воспроизвести сортировку с немедленным выполнением.<br>
```C#
Stopwatch sw = Stopwatch.StartNew();
int[]mass1=Enumerable.Range(1,100000).OrderByDescending(x=>x).ToArray().OrderBy(x=>x).ToArray();
sw.Stop();
Console.WriteLine($"Время немедленного выполнения {sw.ElapsedMilliseconds}mc");//34
sw.Restart();
int[] mass2 = Enumerable.Range(1, 100000).OrderByDescending(x => x).OrderBy(x => x).ToArray();
sw.Stop();
Console.WriteLine($"Время отложенного выполнения{sw.ElapsedMilliseconds}mc");//24
```
<img src="images\itogi.jpg" alt="Выводы" width="100" height="100"><br>
&nbsp;&nbsp;&nbsp; **Выводы**<br>
- Плюсы:
  - Отложенные запросы позволяют вызывать запросы когда это нужно
  - Позволяют оптимизировать сложные запросы
- Минусы:
  - Требуют внимательности при работе с ними 
<br>


**Неполный список LINQ методов**

| Отложенное выполнение  | Немедленное выполнение   |
|:-----------------------|------------------------:|
| AsEnumerable           |               Aggregate |  
| Cast                   |                     All |
| Concat                 |                     Any |
| DefaultIfEmpty         |                 Average |
| Distinct               |                Contains |
| Except                 |                   Count |
| GroupBy                |               ElementAt |
| GroupJoin              |      ElementAtOrDefault |
| Intersect              |                   Empty |
| Join                   |                   First |
| OfType                 |          FirstOrDefault |
| OrderBy                |                    Last |
| OrderByDescending      |           LastOrDefault |
| Range                  |               LongCount |
| Repeat                 |                     Max |
| Reverse                |                     Min |
| Select                 |           SequenceEqual |
| SelectMany             |                  Single |
| Skip                   |         SingleOrDefault |
| SkipWhile              |                     Sum |
| Take                   |                 ToArray |
| TakeWhile              |            ToDictionary |
| ThenBy                 |                  ToList |
| ThenByDescending       |                ToLookup |
| Union
| Where                                           

















  























